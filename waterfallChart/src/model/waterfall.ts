/* ═══════════════════════════════════════════════
   WaterfallChart - Waterfall Computation
   Running totals, bar classification, auto totals
   ═══════════════════════════════════════════════ */

"use strict";

import { WaterfallRawItem, WaterfallBar, BarType, RenderConfig } from "../types";

/**
 * Compute the waterfall bar model from raw items.
 *
 * Logic:
 * - If autoStartTotal: first bar's value is the starting point (base=0, top=value, type=start).
 * - Subsequent bars: base = previous running total, top = base+value.
 * - If isTotal flagged: bar resets to baseline (base=0, top=running total, type=total).
 * - If autoEndTotal: append a computed grand-total bar at the end.
 *
 * Bars are returned in input order (W7: never re-sort).
 */
export function computeWaterfallBars(
    rawItems: WaterfallRawItem[],
    summary: RenderConfig["summary"],
): WaterfallBar[] {
    if (rawItems.length === 0) return [];

    const bars: WaterfallBar[] = [];
    let runningTotal = 0;

    for (let i = 0; i < rawItems.length; i++) {
        const item = rawItems[i];
        const isFirst = i === 0;

        /* ── Determine bar type ── */
        let barType: BarType;
        let base: number;
        let top: number;

        if (item.isTotal) {
            /* Explicit total: sits on baseline from 0 to running total */
            runningTotal = isFirst && summary.autoStartTotal
                ? item.value
                : runningTotal;

            /* If isTotal is flagged, the running total stays as-is
               (the bar simply visualises the current accumulated value) */
            if (!isFirst || !summary.autoStartTotal) {
                /* For non-first total bars, the running total is already correct */
            } else {
                runningTotal = item.value;
            }

            barType = "total";
            base = 0;
            top = runningTotal;
        } else if (isFirst && summary.autoStartTotal) {
            /* Auto-start: first bar is a starting total sitting on baseline */
            runningTotal = item.value;
            barType = "start";
            base = 0;
            top = item.value;
        } else {
            /* Normal incremental bar */
            const prevTotal = runningTotal;
            runningTotal += item.value;

            barType = item.value >= 0 ? "increase" : "decrease";
            base = prevTotal;
            top = runningTotal;
        }

        /* ── Percent change from previous running total ── */
        let pctChangeFromPrevious: number | null = null;
        if (bars.length > 0) {
            const prevRunning = bars[bars.length - 1].runningTotal;
            if (prevRunning !== 0) {
                pctChangeFromPrevious = (runningTotal - prevRunning) / Math.abs(prevRunning);
            }
        }

        bars.push({
            category: item.category,
            value: item.value,
            barType,
            runningTotal,
            base,
            top,
            pctChangeFromPrevious,
            selectionId: item.selectionId,
            tooltipExtras: item.tooltipExtras,
            rowIndex: item.rowIndex,
            isAutoGenerated: false,
        });
    }

    /* ── Auto end-total bar ── */
    if (summary.autoEndTotal && bars.length > 0) {
        const finalTotal = bars[bars.length - 1].runningTotal;
        bars.push({
            category: summary.endTotalLabel || "Total",
            value: finalTotal,
            barType: "total",
            runningTotal: finalTotal,
            base: 0,
            top: finalTotal,
            pctChangeFromPrevious: null,
            selectionId: null,
            tooltipExtras: [],
            rowIndex: -1,
            isAutoGenerated: true,
        });
    }

    return bars;
}

/** Get the min and max of the value domain across all bars. */
export function computeValueDomain(bars: WaterfallBar[]): [number, number] {
    if (bars.length === 0) return [0, 1];

    let min = 0;
    let max = 0;

    for (const bar of bars) {
        const lo = Math.min(bar.base, bar.top);
        const hi = Math.max(bar.base, bar.top);
        if (lo < min) min = lo;
        if (hi > max) max = hi;
    }

    /* Add 10% padding */
    const range = max - min || 1;
    const padding = range * 0.1;
    return [min - padding, max + padding];
}
